---
aliases:
  - 015 Transition 고립성과 동시성 제어
tags:
  - DB
  - Transaction
author: Min Jo
created: 2025-05-01
---
# 015 트랜잭션의 고립성과 동시성 제어 - 성능은 어떻게 유지될까?
-----

트랜잭션(Transaction)의 특징 중 하나인 **고립성(Isolation)**에 대해 공부하던 중 한 가지 의문이 들었습니다.

>**"고립성 때문에 트랜잭션이 순차적으로만 실행된다면, DB 성능은 매우 낮아지는 것 아닌가?"**

하지만 실무에서는 수많은 트랜잭션이 동시에 수행되면서도 성능이 잘 나옵니다.  
어떻게 이러한 성능 저하를 방지하고, 동시에 고립성을 보장할 수 있는 걸까요?

---


### 🔐 고립성(Isolation) 개념 다시 보기

Isolation은 하나의 트랜잭션이 수행 중일 때, **다른 트랜잭션이 그 중간 상태를 볼 수 없도록 보장**하는 성질입니다.  
즉, 격리된 상태로 트랜잭션이 동작해야 데이터의 정합성이 보장됩니다.
그렇다고 모든 트랜잭션을 **순차적으로 처리**한다면? → **성능이 심각하게 떨어집니다.**
그래서 필요한 것이 바로 **동시성 제어(Concurrency Control)**입니다.

----

### 👨‍💻 동시성 제어란? 

동시성 제어는 여러 트랜잭션이 동시에 데이터에 접근해도 정합성을 유지하면서 성능도 확보할 수 있게 만드는 기술입니다. DBMS는 내부적으로 다음과 같은 기법 중 하나를 사용합니다.

| 방식                      | 설명                                                             |
| ----------------------- | -------------------------------------------------------------- |
| **락(Lock)**             | 자원을 점유해서 다른 트랜잭션이 접근하지 못하게 함. 대표: 2단계 잠금(2PL)                  |
| **MVCC (다중 버전 동시성 제어)** | 트랜잭션마다 데이터의 스냅샷을 제공하여 락 없이도 읽기 가능 (예: PostgreSQL, Oracle 일부 등) |
| **타임스탬프 기반 제어**         | 트랜잭션 시작 시간을 기준으로 순서를 관리해 충돌 방지                                 |

> 그리고 여기서 한 가지 더 중요한 점은,  
> **개발자 역시 트랜잭션 간의 고립 정도를 선택할 수 있다는 것**이다.
---
### Isolation Level - 고립성의 단계

개발자가 선택할 수 있는 고립성 수준은 다음과 같습니다:

|Level|설명|MariaDB(InnoDB) 처리 방식|발생 가능한 문제|
|---|---|---|---|
|READ UNCOMMITTED|커밋되지 않은 데이터까지 읽을 수 있음 (가장 낮은 수준)|거의 제약 없음|Dirty Read 발생 가능|
|READ COMMITTED|커밋된 데이터만 읽음|MVCC를 사용하여 Undo 로그 참조|Non-repeatable Read 가능|
|REPEATABLE READ|트랜잭션 내에서는 동일한 쿼리 결과 보장|MVCC로 스냅샷 고정, 팬텀 리드도 방지|**MySQL 기본값**, 균형적|
|SERIALIZABLE|트랜잭션을 직렬 처리 수준으로 강하게 고립|공유 락까지 사용|가장 안전하지만 **가장 느림**|

> 📎 **Note**: MySQL(InnoDB)은 REPEATABLE READ에서도 팬텀 리드를 방지하지만, 대부분의 DB는 그렇지 않습니다.

필자는 현재 MariaDB를 사용하여 서비스를 개발하고 있기때문에 MariaDB로 예시를 든다. 
MariaDB는 읽기와 쓰기에 다른 동시성 제어방식을 택한다.


읽기 (SELECT)
	- **MVCC 사용** 
	- 스냅샷(snapshop)을 기반으로 데이터를 기록한다.
	- 락을 걸지 않기 때문에(다른 트랜잭션에 락을 걸지않음) 동시성이 높고, 읽기 성능이 좋다.
	- undo log 기반으로 과거 버전 조회 (추가 비용은 있지만 대부분 캐시)

 쓰기 (INSERT / UPDATE / DELETE)
- **레코드 단위 Lock (Row-Level Lock)** 사용
- 충돌을 방지하기 위해 해당 레코드에 **X (Exclusive) Lock**을 걸어야 하고, 이로 인해 **대기나 충돌**, **Deadlock**이 발생할 수 있다.
- 쓰기가 많아질수록 성능 병목이 발생할 수 있다.

---

### 예시로 상황 설명하기 - 동시성 제어 방식

이렇게 동시성 제어방식과 고립성의 레벨에 대해서 알아보았다. 
기본적으로 왜 동시성 제어방식을 사용하면 성능이 좋을지 예시로 알아보자.

```sql
SELECT * FROM user ...; --> MVCC 
UPDATE user SET name='Kim'; COMMIT; --> Lock 
```

만약 이러한 쿼리가 동작한다면 조회쿼리가 종료된 이후에 쓰기쿼리가 동작하는게 아닌 다음과 같은 방식으로 진행이된다.

#### 예시:

- 트랜잭션 A가 어떤 데이터를 읽고 있어도,
- 트랜잭션 B는 그 데이터를 자유롭게 수정할 수 있고,
- 둘은 서로 **서로를 기다릴 필요가 없다**.
  📌 즉, **읽는 동안 다른 트랜잭션을 기다리지 않기 때문에 동시성이 매우 높다.**



---
