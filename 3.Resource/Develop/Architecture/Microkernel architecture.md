
마이크로커널 아키텍쳐 (microkernel / plug-in architecture)

### **코어 시스템**

- 시스템을 실행시키는 데 필요한 최소한의 기능


### **플러그인**

특정 처리 로직, 부가 기능뿐만 아니라 코어 시스템의 기능 변경을 위한 Add-on 스타일을 지원하는 standalone 컴포넌트
코어 시스템 자체를 개선/확장할 수 있는 역할을 한다는 것과 **standalone** 이어야 한다는 것이다. 즉, 다른 플러그인이 없으면 동작할 수 없는 형태가 아닌 단독 플러그인으로써의 동작을 보장해야한다는 것이다.
일반적으로 플러그인은 코어시스템과 point-to-point 관계이며, 따라서 대부분의 연결고리는 entry-point class를 호출해주는 메서드나 함수이다.



StandAlone ? 
point-to-point 란 
entry-point class 
runtime-based  plugin-add one 방식말고 다른것도 있나 찾아보자.


### **레지스트리 (Registry)**

> 플러그인들의 정보를 등록/관리하는 곳

코어시스템은 어떤 플러그인들이 존재하는지 알아야 로드해서 사용할 수 있을 것이다.
이러한 시스템을 위한 가장 일반적인 구현 방법은 "**플러그인 레지스트리**" 이다
레지스트리에는 플러그인을 사용하기 위한 정보들. 즉, 어떠한 플러그인들이 존재하고, 이름은 무엇인지 데이터 입출력은 어떤지, 어떻게 로드할 수 있는지(프로토콜) 등등의 정보를 넣고 관리할 수 있다.


### **계약 (Contract)**

> 코어시스템에서 플러그인을 사용하기 위한 행위

코어 시스템에서 플러그인을 사용하기 위해서는 레지스트리로부터 플러그인에 대한 정보를 가져온 다음 이것은 시스템에 등록하고 사용해야한다. 그리고 사용이 다 끝나면 해제(메모리와 관련됨)해주어야 한다.
일반적으로 이 계약은 XML이나 JSON형태를 통해 코드 없이 하는 방식을 채택한다. 이것은 코어 시스템과 플러그인이 의존성 없이 독립적으로 존재할 수 있게 해준다. 즉, 레지스트리로부터 이 정보들을 얻어 플러그인을 로드하고 사용하면 된다.
컨트랙트의 플로우는 assess, register, deregister 의 흐름이며, 먼저 플러그인에 대한 정보를 확인하고, 등록(로드)하고 사용하다가 더 이상 사용하지 않는다면 해제(언로드)하는 방식이다.