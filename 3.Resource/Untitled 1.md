해당 ERD 이미지를 확인하고 검토를 제공하기 위해, 주요 테이블 및 관계를 분석하고 필요한 개선 사항을 정리하겠습니다. 아래는 검토 내용입니다:

---

## **1. 주요 테이블 및 구조 검토**

### **(1) User 테이블**
- `User` 테이블이 `User_follow`, `Plan`, `Favorite` 등 다양한 테이블과 적절히 연결되어 있습니다.
- 필드 설계:
  - `password`, `oauth_id`, `profile`, `name` 등이 포함되어 있어 일반 로그인과 소셜 로그인을 모두 지원할 수 있는 구조로 보입니다.
  - **제안**:
    - `oauth_id`와 같은 필드가 `null`일 수 있는 경우를 명시적으로 처리하세요 (예: 소셜 로그인 사용자의 경우 비밀번호가 없으므로 `nullable` 여부 확인 필요).

---

### **(2) User_follow 테이블**
- 유저 간 팔로우/팔로워 관계를 잘 나타내고 있습니다.
- 필드 설계:
  - `유저_id`, `팔로우_id`, `상태(status)`로 구성되어 있어 팔로우 상태를 관리 가능.
  - **제안**:
    - `status`는 ENUM으로 되어 있으므로 값의 범위를 문서화하거나 관리 도구를 제공하는 것이 좋습니다 (`PENDING`, `ACCEPTED`, `REJECTED` 등).
    - 복합키 `유저_id + 팔로우_id`를 `UNIQUE`로 설정해 중복 팔로우 방지 확인 필요.

---

### **(3) Plan 테이블**
- 유저가 작성한 여행 계획 정보를 저장합니다.
- 필드 설계:
  - `여행시작일`, `여행종료일` 등의 필드를 포함하여 여행 기간을 관리.
  - `임시저장`(boolean 필드로 보임)을 통해 계획을 초안 상태로 관리 가능.
- **제안**:
  - `여행시작일`과 `여행종료일`은 `CHECK` 제약 조건을 사용해 종료일이 시작일 이후인지 확인할 수 있습니다.
  - 계획이 삭제되었을 때 관련 리뷰(Plan_Reviews)나 댓글(Post_comment)이 어떻게 처리될지 설정 필요 (`ON DELETE CASCADE` 등).

---

### **(4) Post 테이블**
- 유저가 작성한 게시글 정보를 저장하며, `Post_image` 및 `Post_comment`와 연결되어 있습니다.
- 필드 설계:
  - `like`(좋아요), `views`(조회수) 등을 포함하여 게시글의 통계를 관리 가능.
- **제안**:
  - `조회수` 필드는 증가 연산이 빈번하므로 캐싱 또는 비동기 방식으로 업데이트하는 전략 고려.
  - `좋아요`는 `Favorite` 테이블로 분리되어 있으므로 중복된 데이터 관리 가능성 점검 필요.

---

### **(5) Favorite 테이블**
- 유저가 특정 게시글을 즐겨찾기한 정보를 관리합니다.
- 필드 설계:
  - `유저_id`와 `게시글_id`를 연결.
- **제안**:
  - `UNIQUE (유저_id, 게시글_id)` 제약 조건을 통해 중복 즐겨찾기 방지 확인.

---

### **(6) Location 및 Location_follow 테이블**
- 지역 정보를 관리하며, 특정 사용자가 지역을 팔로우하는 관계를 설정합니다.
- 필드 설계:
  - `location` 테이블에서 `위치_id`와 `지역명` 필드가 잘 설계.
  - `Location_follow` 테이블에서 `유저_id`와 `code_id`로 팔로우 관리.
- **제안**:
  - `Location_follow` 테이블의 `code_id`는 `location.code_id`를 참조하므로 외래키 제약 조건 (`FOREIGN KEY`) 확인 필요.
  - `code_id`가 의미하는 구체적인 데이터(예: ISO 지역 코드 등)를 명확히 정의.

---

### **(7) Spot 테이블**
- 여행 명소 정보를 관리하며, 명소의 상세 정보(위도, 경도, 가격 등)를 포함합니다.
- **제안**:
  - `시작시간` 및 `종료시간` 필드는 특정 명소의 개방 시간으로 보입니다. 이는 시간 관리 로직과의 연계가 필요.
  - 명소가 특정 Location과 연결된 구조(`location_id`를 참조)로 보이므로 외래키 설정 확인.

---

## **2. 테이블 간 관계 검토**

### **(1) User → User_follow**
- 유저 간의 팔로우 관계를 적절히 모델링.
- **제안**: 
  - 양방향 팔로우 데이터를 처리해야 하는 경우 추가 쿼리 설계 필요 (`A가 B를 팔로우`와 `B가 A를 팔로우`).

### **(2) User → Plan → Plan_Reviews**
- 계획(Plan)과 리뷰(Plan_Reviews)가 연결되어 있어 유저의 여행 리뷰를 관리 가능.
- **제안**:
  - 리뷰 삭제 시, 관련 데이터 처리 방법 (`ON DELETE CASCADE` 또는 `SET NULL`) 정의.

### **(3) Post → Post_image & Post_comment**
- 게시글(Post)과 이미지(Post_image), 댓글(Post_comment)의 관계가 잘 정의.
- **제안**:
  - 댓글 및 이미지 데이터가 대량으로 쌓일 경우 성능 최적화 방안(예: 페이징) 고려.

### **(4) Plan → Spot**
- 여행 계획(Plan)과 명소(Spot)가 연결되어 있어 계획 내 명소를 관리 가능.
- **제안**:
  - Spot 테이블과 Plan 간 연결이 다대다 관계로 발전할 가능성이 있음 (`Plan_Spot` 중간 테이블 필요 여부 확인).

---

## **3. 성능 최적화 제안**

1. **인덱스 추가**:
   - 외래 키 필드(`유저_id`, `게시글_id`, `위치_id` 등)에 인덱스를 추가하여 조회 성능을 향상.
   - 예: `Plan` 테이블의 `유저_id`에 인덱스 추가.

2. **캐싱 전략**:
   - `조회수`와 같은 잦은 업데이트가 필요한 데이터는 Redis 등 캐시를 활용.

3. **파티셔닝**:
   - `Plan`, `Post`, `Post_comment`처럼 데이터가 빠르게 쌓일 가능성이 있는 테이블에 파티셔닝 고려.

4. **정규화와 비정규화**:
   - 테이블 간 관계를 지나치게 세분화하면 성능 저하가 있을 수 있으므로, 자주 사용하는 데이터는 비정규화 가능.

---

## **4. 추가적으로 확인할 점**
1. **삭제 정책**:
   - 계획(Plan), 게시글(Post) 등 주요 엔터티가 삭제될 때 연관된 데이터(Follow, Review 등)가 어떻게 처리될지 명확히 정의.

2. **상태 관리**:
   - ENUM 필드(`status`, `type` 등)의 값 정의를 문서화하여 데이터의 일관성 유지.

3. **확장 가능성**:
   - 새로운 기능 추가(예: 태그, 알림 시스템 등)를 고려한 설계 유연성.

---

## **최종 요약**
- 전체적으로 ERD가 유저와 여행, 게시글, 즐겨찾기, 팔로우 등 주요 기능을 잘 반영하고 있음.
- 일부 테이블 간 관계에서 외래 키 제약 조건과 삭제 정책의 명확화가 필요.
- 성능 최적화를 위해 인덱스와 캐싱 전략 검토 권장.


k8s -> 
aws -> 




[GIT 사업관리]  
- 베타 테스트용 서버 배포 준비  
- 베타 테스트 관련 회의 진행