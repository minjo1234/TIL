
# 010 K8s 용어정리
---


### 클라우드 
광대한 네트워크를 통하여 접근할 수 있는 가상화 된 서버와, 서버에서 작동하는 프로그램, 데이터베이스를 제공하는 IT 환경

### 클라우드 vs 클라우드 컴퓨팅 vs 클라우드 서비스
클라우드 컴퓨팅 : 클라우드를 이용하여 컴퓨터 자원을 이용하는 방법
클라우드 서비스 : SaaS, PaaS, IaaS


----

### 온프레미스(On-Permise)

기업이 자체적으로 IT인프라를 소유, 관리 및 운영한다.

#### 온프레미스 vs 오프 프레미스(Off-Permise)



#### 개발 워크플로
#### 롤링 업데이트 
#### 컨테이너를 이용한 배치 작업 및 예약 작업

#### 매니페스트 


### 쿠버네티스가 하는일 

기존 vs 현재 
인프라스트럭처에서의 로드밸런싱, 네트워크, 스토리지 컴퓨팅
-> 애플리케이션 설정의 영역

개요 : 
쿠버네티스는 컨테이너를 실행하는 플랫폼

핵심 개념 
1.애플리케이션 정의에 사용되는 API 
2.실제로 동작하는 클러스터 

클러스터는 도커 같은 컨테이너 런타임에 동작하는 여러대의 서버가 모두 쿠버네티스 같은 ㅏ나의 논리적 단위를 구성한다.
클러스터 -> 도커 컨테이너 여러개 모아서 구성함 

오케스트레이션 

쿠버네티스는 컨테이너 오케스트레이션 도구 
클러스트는 여러개의 노드로 구성
일부 노드는 쿠버네티스 API 실행
나머지노드는 컨테이너 동작하는 어플리케이션 실행

쿠버네티스는 기본적으로  리눅스 노드상의 컨테이너에서 동작
하지만 클러스터 자체는 다른 플랫폼의 노드 포함가능
Window 노드추가하면 리눅스와 윈도우 환경에서 모두 가능하다.

쿠버네티스는 여러가지 컨테이너 런타임을 지원하는데 도커,  containered, rkt 


클러스터 관리자는 노드라고 하는 각각의 서버를 관리 
롤링 업데이트 기능 :노드는 추가, 제거, 업데이트를 하는 

클러스터의 목적: 애플리케이션 실행 

YAML -> 애플리케이션 -> 쿠버네티스 API로 전달 ( 해당 API를 이용하여 애플리케이션을 실행한다.)

컨테이너는 고가용성을 위해 여러 노드에 흩어져있다.


쿠버네티스 클러스터란 
- 어플리케이션을 실행하고 관리하기 위한 하나의 단위 
- 마스터 노드(Control Plane) : 클러스터 전체를 관리 
- 워커 노드  : 실제로 어플리케이션(컨테이너) 실행되는 곳 
  

### 오케스트레이션이란?

> 여러 개의 마이크로서비스, 컨테이너, 작업(배포, 확장, 로깅, 모니터링 등)을  
> **자동으로 관리하고 조정**하는 것



---

하나의 클러스터에는 

- 여러개의 노드가 존재할 수 있고
- 각 노드는 여러개의 컨테이너(=pod) 로 구성된다.


노드는 운영체제가 설치된 머신

|계층|역할|예시|
|---|---|---|
|☁ 클라우드|인프라 제공|AWS, GCP, Azure|
|💻 VM/노드|실행 환경 (운영체제 있는 서버)|Ubuntu VM, Windows VM|
|🐳 Docker|앱을 실행하는 컨테이너 기술|nginx 컨테이너, spring 컨테이너|
|☸ Kubernetes|컨테이너들을 자동으로 관리|클러스터, 노드, 파드 등|

## 📦 왜 Docker만으로는 부족할까?

|Docker 단독 운영|Kubernetes|
|---|---|
|컨테이너 직접 띄워야 함|자동으로 배포됨|
|수동 스케일링|자동 스케일링|
|장애 복구 X|장애 감지 후 자동 복구|
|노드 자원 관리 X|노드 상태 보고 알아서 배치|

1.도커가 있는데 쿠버네티스를 사용하였을때의 장점 
장점은 노드가 고장되었을때 
하나의 노드에서 고장이 이러난다면 해당 노드에서 실행되던 컨테이너는 다른 노드에서 실행된 컨테이너로 대체. 특정한 컨테이너가 이상을 일으켰다면 쿠버네티스는 해당 컨테이너를 재시작 

2.클러스터에는 분산데이터 베이스가 들어있다. - 애플리케이션 구성정보, APl, 패스워드 비밀값 

쿠버네티스는 스토리를 제공한다. 외부에 데이터를 저장가능 
트래픽을 관리,


쿠버네티스의 장점은 어플리케이션과 상관없이 모든 애플리케이션을 (자바, Node.js, Go)
모두 똑같은 방식으로 기술하고 배포관리가 가능하다.

애플리케이션을 기술한 yaml 파일은 애플리케이션 매니페스트.(application manifest )
파일 내용이 애플리케이션을 구성한 모든 컴포넌트의 목록이라는 뜨이다.


서비스  - 네트워크 접근을 관리한다.  트래픽이나, 컨테이너 간 통신을 전달 
레플리카셋 (파드 - 볼륨, 비밀값로 구성)
디폴로이먼트
컨피그맵 

쿠버네티스 API 이용법  - 쿠버네티스 클러스터에 접속한후 API를 이용하여 클러스터를 관리

kubetcl 설치법 

```
# macOS
brew install Kubernetes-cli
```


쿠버네티스는 컨테이너를 이용하여 애플리케이션을 실행, 하지만 사용자는 컨테이너를 직접 다루지않고 컨테이너를 파드라고 지칭한다.
파드 : 쿠버테니스는 하나 또는 그 이상의 컨테이너를 관리하는데 사용하는 단위 

파드는 리소스 관리하고, 고수준 리소느는 컨테이너의 세부 사항을 추상화  -  자가수복형 어플리케이션이나 바람직한 상태 워크플로가 가능해지는 이유이다 (고수준 리소스로 관리하기때문에) 
-> 바람직한 상태 워크플로가 가능해진다.


쿠버네티스의 기본 단위이자 컨테이너를 실제 실행하는 역할 - 디플로이먼트 (deployment) 

컨테이너는 일반적으로 애플리케이션 구성 요소를 하나를 실행하는 가상화된 환경  이걸 파드로감싼다 -> 그리고 이건 클러스트중의 하나의 노드에서 실행된다. 

파드는 클러스터로 관리되는 자신만의 노드를 가진다.
가상 네트워크로 다른파드 , 다른 노드에서 실행되더라도 통신이 가능한 이유가 이 이유이다.


파드는 하나의 컨테이너를 포함할수도 여러개의 컨테이너를 포함할수도있다.
파드에 포함된 컨테이너는 같은 가상환경에 속한다.
네트워크를 공유하며 localhost를 서로 통신할 수도있다.


컨테이너(단일 또는 여러개) -> 파드로 감싸짐 - deployment에 의해서 실행 - 클러스터로 구성된다.

같은 파드는 같은 IP를 공유 
파드는 독자만의 IP를 가져서 다른 파드와 또는 다른 노드의 파드와 소통이 가능하다.


#### 질문) 파드가 여러 컨테이너를 포함할 수 있다고 하였는데 
왜 그냥 컨테이너를 직접 다루지 않고 파드를 거치는지 

쿠버네티스는 직접 컨테이너를 실행하지 않는다.
컨테이너를 생성할 책임을 해당 노드에 설치된 컨테이너 런타임에 맡긴다.

파드는 쿠버네티스가 관리하는 리소스
컨테이너는 쿠버네티스 외부에서 관리

kubecltl 리소스 정보 중 원하는 정보에 마음대로 접근할 수 있고 특히 자동화할때 편리하다.  두 번째는 컨테이너를 직접실행하는 것은 쿠버네티스가 아니다.

노드가 컨테이너를 실행시키고
컨테이너 런타임 인터페이스라는 공통 API를 이용하여 컨테이너 런타이모가 연동되는 형태로 진행된다.


파드의 컨테이너 개수가 0이 되지마자 쿠버네티스 측에서 즉각적으로 대체 컨테이너를 생성하여 파드를 복원 
쿠버네티스가 제공하는 자가수복성의 첫 번째 단계, 파드 위로 더 쌓일수록 애플리케이션은 이 이상의 복원력 
파드 위로 얹히는 또 다른 추상화 중 하나가 바로 디플로이먼트 

기본적으로 localhost에 존재하는 Pod에 접근이 불가능한데 
그 이유느 네트워크 트래픽을 받아들일수없기때문이다. 하지만 노드에서  트래픽을 파드로 전달 할 수 있다면 이게 가능한데,  파드는 쿠버네티스에서 컴퓨팅의 최소단위이다.


파드만 봤을때는 정말 간단한데 파드는 고립된 하나의 어플리케이션 
각 파드는 서로 다른 노드에 배정된다.
어떤 노드가 고장일으킨다면 파드는 유실 쿠버네티스는 유실된 파드를 새로운 파드로 교체하지않음
모든 파드가 다른 노드에 실행된다는 보장이없는데, 이걸 사람이 해야한다면 오케스트레이션 도구를 사용하는 의미가 존재하지 않는다.

-> 컨트롤러 객체가 이걸 해결해준다. 다른 리소르를 관리해주는 쿠버네티스 리소스 
컨트롤러는 쿠버네티스 API와 연동하며 시스템의 현재 상태를 감시하다가 바람직한 상태와 차이가 생기면 필요에 따라 그 차이를 바로잡는다.

파드를 관리하는 컨트롤러 객체 디플로이먼트
노드가 고장을 일으켜 파드가 유실되면 
디플로이먼트가 대체 파드를 다른 노드에 실행한다 -> 어떤노드에 실행시키는지, 왜 다른 노드에 실행시키는지 

디플로이먼트는 파드를관리하고 파드는 컨테이너를 관리한다.
쿠버네티스가 디플로이먼트를 생성하면 디플로이먼트는 파드를 생성한다.



```bash
$ kubectl port-forward pod/hello-kiamol 8080:80
```

디플로이먼트가 생성한 파드 이름은 쿠버테니스가 지은 것으로,
디플로이먼트 이름 뒤에 무작위 문자열이 붙은 형태이다.

디플로이먼트만 만들면 파드는 알아서 만들어준다.
하지만 알아야할점 디플로이먼트는 어떻게 자신이 관리해야  할 리소스를 어떻게 추적하는 지 알아 둘 필요가 존재하낟.
모든 쿠버네티스 리소스는 간단한 키-값 쌍 형태의 레이블을 가진다.

디플로이먼트는 자신이 생성한 파드에 레이블을 부여하며, 이 레이블을 기준을 디플로이먼트가 생성한 파드를 찾을 수 있다.

컨트롤러가 자신이 관리하는 리소르 목록을 직접 유지하지 않아도, 레이블 셀렉터가 컨트롤러 객체에 정의에 포함되어 있어 쿠버테니스 API를 통해 자신이 관장하는 리소스를 찾아볼 수 있다.
레이블 정보를 함부로 수정하면 리소스 간 관계를 흐트러뜨릴 수 있기 때문에 주의해야한다.

디플로이먼트는 자신이 직접 파드를 관리하지 않고, 레이블 셀렉터와 일치하는 파드만 검색가능하다.
만약 레이블 셀렉터를 변경한다면 디플로이먼트는 레이블 셀렉트와 일치하는 파드가 없어 새로운 파드를 만든다.

------

### 클러스터 관리자 

